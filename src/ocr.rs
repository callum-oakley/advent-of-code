use std::sync::LazyLock;

use crate::grid::Grid;

static KNOWN: LazyLock<Vec<(&str, &str)>> = LazyLock::new(|| {
    vec![
        (
            "
            .##..####.#....####.#.....##..#...#####..##...###.
            #..#.#....#....#....#....#..#.#...##....#..#.#....
            #....###..#....###..#....#..#..#.#.###..#....#....
            #....#....#....#....#....#..#...#..#....#.....##..
            #..#.#....#....#....#....#..#...#..#....#..#....#.
            .##..#....####.####.####..##....#..#.....##..###..
            ",
            "CFLELOYFCS",
        ),
        (
            "
            #...#..###
            #...#...#.
            #...#...#.
            #####...#.
            #...#...#.
            #...#...#.
            #...#...#.
            #...#..###
            ",
            "HI",
        ),
        (
            "
            ######..#####...#....#..#....#..#.......######....##.....####.
            #.......#....#..#....#..#...#...#.......#........#..#...#....#
            #.......#....#..#....#..#..#....#.......#.......#....#..#.....
            #.......#....#..#....#..#.#.....#.......#.......#....#..#.....
            #####...#####...######..##......#.......#####...#....#..#.....
            #.......#....#..#....#..##......#.......#.......######..#..###
            #.......#....#..#....#..#.#.....#.......#.......#....#..#....#
            #.......#....#..#....#..#..#....#.......#.......#....#..#....#
            #.......#....#..#....#..#...#...#.......#.......#....#..#...##
            #.......#####...#....#..#....#..######..######..#....#...###.#
            ",
            "FBHKLEAG",
        ),
        (
            "
            ###..#..#.###..####.#..#.
            #..#.#..#.#..#.#....#..#.
            #..#.####.#..#.###..#..#.
            ###..#..#.###..#....#..#.
            #....#..#.#....#....#..#.
            #....#..#.#....####..##..
            ",
            "PHPEU",
        ),
        (
            "
            ###....##.#....####.###..#..#..##..#..#
            #..#....#.#....#....#..#.#..#.#..#.#..#
            #..#....#.#....###..###..#..#.#....#..#
            ###.....#.#....#....#..#.#..#.#....#..#
            #.#..#..#.#....#....#..#.#..#.#..#.#..#
            #..#..##..####.#....###...##...##...##.
            ",
            "RJLFBUCU",
        ),
        (
            "
            ###..####.#..#.###...##....##.####.#..#
            #..#.#....#.#..#..#.#..#....#....#.#..#
            ###..###..##...#..#.#.......#...#..#..#
            #..#.#....#.#..###..#.......#..#...#..#
            #..#.#....#.#..#.#..#..#.#..#.#....#..#
            ###..#....#..#.#..#..##...##..####..##.
            ",
            "BFKRCJZU",
        ),
    ]
});

pub fn parse(g: impl Into<Grid<bool>>) -> &'static str {
    let s = g.into().to_string();
    for (image, word) in &*KNOWN {
        if s.trim() == image.trim().replace(' ', "") {
            return word;
        }
    }
    panic!("failed to parse:\n{s}");
}
